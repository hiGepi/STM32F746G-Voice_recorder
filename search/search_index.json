{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur le projet d'enregistreur vocal ! Introduction Paricipant \u00e0 un TER sur de la reconnaissance vocale, la g\u00e9n\u00e9ration d'un mod\u00e8le de reconnaissance vocale n\u00e9cessite d'avoir un dictionnaire de mot et des enregistrements audio associ\u00e9s. Ce dictionnaire contient nottament des nom de cellules qui ne se trouvent pas dans les bases de donn\u00e9es open-source. Ainsi, nous avons cr\u00e9\u00e9 un script Matlab permettant d'enregistrer la voix de volontaires. Afin de permettre d'enregistrer un plus grand nombre de donn\u00e9es, j'ai d\u00e9cid\u00e9 de porter ce script sous forme d'application sur la carte STM32F746G. Voici donc la nouvelle carte. Carte STM32F746G-Discovery et son extension Ainsi que le sch\u00e9ma synoptique expliquant le fonctionnement du projet. Sch\u00e9ma synoptique Besoins du projet Nous avons besoin de receuillir des fichiers audio pour une liste de mot appel\u00e9e dictionnaire. Pour ce faire, la carte dispose d'un Codec audio permettant de faire l'acquisition de la voix par l'interface de deux microphones sur la carte. Le but \u00e9tant de pouvoir r\u00e9cup\u00e9rer ces acquisitions pour les donner \u00e0 un r\u00e9seau de neuronnes con\u00e7u pour g\u00e9n\u00e9rer un mod\u00e8le de reconnaissance vocale, il faut les enregistrer sur un espace de stockage amovible. Bingo ! il y a un slot pour carte micro-SD. Probl\u00e9matiques Fichier .wav Afin d'enregistrer des fichiers audio, il faut pouvoir les stocker sous format .wav sur la carte. Il faut pour cela, \u00e9crire une ent\u00eate dans les fichiers permettant de reconna\u00eetre le type : [Bloc de d\u00e9claration d'un fichier au format WAVE] FileTypeBlocID (4 octets) : Constante \u00ab RIFF \u00bb (0x52,0x49,0x46,0x46) FileSize (4 octets) : Taille du fichier moins 8 octets FileFormatID (4 octets) : Format = \u00ab WAVE \u00bb (0x57,0x41,0x56,0x45) [Bloc d\u00e9crivant le format audio] FormatBlocID (4 octets) : Identifiant \u00ab fmt\u2423 \u00bb (0x66,0x6D, 0x74,0x20) BlocSize (4 octets) : Nombre d'octets du bloc - 16 (0x10) AudioFormat (2 octets) : Format du stockage dans le fichier (1: PCM entier, 3: PCM flottant, 65534: WAVE_FORMAT_EXTENSIBLE) NbrCanaux (2 octets) : Nombre de canaux (de 1 \u00e0 6, cf. ci-dessous) Frequence (4 octets) : Fr\u00e9quence d'\u00e9chantillonnage (en hertz) [Valeurs standardis\u00e9es : 11 025, 22 050, 44 100 et \u00e9ventuellement 48 000 et 96 000] BytePerSec (4 octets) : Nombre d'octets \u00e0 lire par seconde (c.-\u00e0-d., Frequence * BytePerBloc). BytePerBloc (2 octets) : Nombre d'octets par bloc d'\u00e9chantillonnage (c.-\u00e0-d., tous canaux confondus : NbrCanaux * BitsPerSample/8). BitsPerSample (2 octets) : Nombre de bits utilis\u00e9s pour le codage de chaque \u00e9chantillon (8, 16, 24) [Bloc des donn\u00e9es] DataBlocID (4 octets) : Constante \u00ab data \u00bb (0x64,0x61,0x74,0x61) DataSize (4 octets) : Nombre d'octets des donn\u00e9es (c.-\u00e0-d. \"Data[]\", c.-\u00e0-d. taille_du_fichier - taille_de_l'ent\u00eate (qui fait 44 octets normalement). DATAS[] : [Octets du Sample 1 du Canal 1] [Octets du Sample 1 du Canal 2] [Octets du Sample 2 du Canal 1] [Octets du Sample 2 du Canal 2] * Les Canaux : 1 pour mono, 2 pour st\u00e9r\u00e9o NOTES IMPORTANTES : Les octets des mots sont stock\u00e9s sous la forme Petit-boutiste (c.-\u00e0-d., en \"little endian\") [87654321][16..9][24..17] [8..1][16..9][24..17] [... On remarque la n\u00e9cessit\u00e9 de conna\u00eetre la taille de l'\u00e9chantillon \u00e0 sauvegarder. La dur\u00e9e d'enregistrement de chaque mots n'exc\u00e9dent pas 4 secondes, soit pour une fr\u00e9quence d'\u00e9chantillonnage de 16 kHz, une taille de 64 Ko en mono. La taille de la RAM dont dispose la carte STM32 est de 340 Ko, il n'y aura a priori pas de probl\u00e8me majeur pour stocker chaque \u00e9chantillon sur la carte entre deux \u00e9critures sur la carte SD. Pour des enregistrements plus cons\u00e9quents, on pourra toujours utiliser la SDRAM pouvant stocker jusqu'\u00e0 64 Mo.","title":"Projet"},{"location":"#bienvenue-sur-le-projet-denregistreur-vocal","text":"","title":"Bienvenue sur le projet d'enregistreur vocal !"},{"location":"#introduction","text":"Paricipant \u00e0 un TER sur de la reconnaissance vocale, la g\u00e9n\u00e9ration d'un mod\u00e8le de reconnaissance vocale n\u00e9cessite d'avoir un dictionnaire de mot et des enregistrements audio associ\u00e9s. Ce dictionnaire contient nottament des nom de cellules qui ne se trouvent pas dans les bases de donn\u00e9es open-source. Ainsi, nous avons cr\u00e9\u00e9 un script Matlab permettant d'enregistrer la voix de volontaires. Afin de permettre d'enregistrer un plus grand nombre de donn\u00e9es, j'ai d\u00e9cid\u00e9 de porter ce script sous forme d'application sur la carte STM32F746G. Voici donc la nouvelle carte. Carte STM32F746G-Discovery et son extension Ainsi que le sch\u00e9ma synoptique expliquant le fonctionnement du projet. Sch\u00e9ma synoptique","title":"Introduction"},{"location":"#besoins-du-projet","text":"Nous avons besoin de receuillir des fichiers audio pour une liste de mot appel\u00e9e dictionnaire. Pour ce faire, la carte dispose d'un Codec audio permettant de faire l'acquisition de la voix par l'interface de deux microphones sur la carte. Le but \u00e9tant de pouvoir r\u00e9cup\u00e9rer ces acquisitions pour les donner \u00e0 un r\u00e9seau de neuronnes con\u00e7u pour g\u00e9n\u00e9rer un mod\u00e8le de reconnaissance vocale, il faut les enregistrer sur un espace de stockage amovible. Bingo ! il y a un slot pour carte micro-SD.","title":"Besoins du projet"},{"location":"#problematiques","text":"","title":"Probl\u00e9matiques"},{"location":"#fichier-wav","text":"Afin d'enregistrer des fichiers audio, il faut pouvoir les stocker sous format .wav sur la carte. Il faut pour cela, \u00e9crire une ent\u00eate dans les fichiers permettant de reconna\u00eetre le type : [Bloc de d\u00e9claration d'un fichier au format WAVE] FileTypeBlocID (4 octets) : Constante \u00ab RIFF \u00bb (0x52,0x49,0x46,0x46) FileSize (4 octets) : Taille du fichier moins 8 octets FileFormatID (4 octets) : Format = \u00ab WAVE \u00bb (0x57,0x41,0x56,0x45) [Bloc d\u00e9crivant le format audio] FormatBlocID (4 octets) : Identifiant \u00ab fmt\u2423 \u00bb (0x66,0x6D, 0x74,0x20) BlocSize (4 octets) : Nombre d'octets du bloc - 16 (0x10) AudioFormat (2 octets) : Format du stockage dans le fichier (1: PCM entier, 3: PCM flottant, 65534: WAVE_FORMAT_EXTENSIBLE) NbrCanaux (2 octets) : Nombre de canaux (de 1 \u00e0 6, cf. ci-dessous) Frequence (4 octets) : Fr\u00e9quence d'\u00e9chantillonnage (en hertz) [Valeurs standardis\u00e9es : 11 025, 22 050, 44 100 et \u00e9ventuellement 48 000 et 96 000] BytePerSec (4 octets) : Nombre d'octets \u00e0 lire par seconde (c.-\u00e0-d., Frequence * BytePerBloc). BytePerBloc (2 octets) : Nombre d'octets par bloc d'\u00e9chantillonnage (c.-\u00e0-d., tous canaux confondus : NbrCanaux * BitsPerSample/8). BitsPerSample (2 octets) : Nombre de bits utilis\u00e9s pour le codage de chaque \u00e9chantillon (8, 16, 24) [Bloc des donn\u00e9es] DataBlocID (4 octets) : Constante \u00ab data \u00bb (0x64,0x61,0x74,0x61) DataSize (4 octets) : Nombre d'octets des donn\u00e9es (c.-\u00e0-d. \"Data[]\", c.-\u00e0-d. taille_du_fichier - taille_de_l'ent\u00eate (qui fait 44 octets normalement). DATAS[] : [Octets du Sample 1 du Canal 1] [Octets du Sample 1 du Canal 2] [Octets du Sample 2 du Canal 1] [Octets du Sample 2 du Canal 2] * Les Canaux : 1 pour mono, 2 pour st\u00e9r\u00e9o NOTES IMPORTANTES : Les octets des mots sont stock\u00e9s sous la forme Petit-boutiste (c.-\u00e0-d., en \"little endian\") [87654321][16..9][24..17] [8..1][16..9][24..17] [... On remarque la n\u00e9cessit\u00e9 de conna\u00eetre la taille de l'\u00e9chantillon \u00e0 sauvegarder. La dur\u00e9e d'enregistrement de chaque mots n'exc\u00e9dent pas 4 secondes, soit pour une fr\u00e9quence d'\u00e9chantillonnage de 16 kHz, une taille de 64 Ko en mono. La taille de la RAM dont dispose la carte STM32 est de 340 Ko, il n'y aura a priori pas de probl\u00e8me majeur pour stocker chaque \u00e9chantillon sur la carte entre deux \u00e9critures sur la carte SD. Pour des enregistrements plus cons\u00e9quents, on pourra toujours utiliser la SDRAM pouvant stocker jusqu'\u00e0 64 Mo.","title":"Fichier .wav"},{"location":"app/","text":"Cr\u00e9ation de l'application","title":"Application"},{"location":"app/#creation-de-lapplication","text":"","title":"Cr\u00e9ation de l'application"},{"location":"audio/","text":"Audio Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation du codec audio WM8994 ainsi que son utilisation. La communication avec le codec se fera \u00e0 l'aide de l'interface SAI. Documentation Codec WM8994 Un Codec est un dispositif mat\u00e9riel permettant de mettre en oeuvre l'encode ou le d\u00e9codage d'un flux de donn\u00e9es num\u00e9rique, en vue d'une transmission ou d'un stockage. I/O Codec WM8994 Celui-ci pr\u00e9sente Lien doc WM8994 SAI Diagramme SAI Lien doc SAI DMA Lien doc DMA Ajout de la biblioth\u00e8que On active l'interface SAI dans Multimedia avec une liaison Maitre et une laison Esclave synchrone. Les requ\u00eates se font alors avec le DMA avec la configuration suivante Une fois tout ceci fait, on peut rajouter les headers et fichiers sources dans notre projet. Fonctions principales","title":"Audio"},{"location":"audio/#audio","text":"Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation du codec audio WM8994 ainsi que son utilisation. La communication avec le codec se fera \u00e0 l'aide de l'interface SAI.","title":"Audio"},{"location":"audio/#documentation","text":"","title":"Documentation"},{"location":"audio/#codec-wm8994","text":"Un Codec est un dispositif mat\u00e9riel permettant de mettre en oeuvre l'encode ou le d\u00e9codage d'un flux de donn\u00e9es num\u00e9rique, en vue d'une transmission ou d'un stockage. I/O Codec WM8994 Celui-ci pr\u00e9sente Lien doc WM8994","title":"Codec WM8994"},{"location":"audio/#sai","text":"Diagramme SAI Lien doc SAI","title":"SAI"},{"location":"audio/#dma","text":"Lien doc DMA","title":"DMA"},{"location":"audio/#ajout-de-la-bibliotheque","text":"On active l'interface SAI dans Multimedia avec une liaison Maitre et une laison Esclave synchrone. Les requ\u00eates se font alors avec le DMA avec la configuration suivante Une fois tout ceci fait, on peut rajouter les headers et fichiers sources dans notre projet.","title":"Ajout de la biblioth\u00e8que"},{"location":"audio/#fonctions-principales","text":"","title":"Fonctions principales"},{"location":"files/","text":"Fichiers STM32F746G-Discovery Vous retrouverez ici les .h et .c n\u00e9cessaires au bon fonctionnement des biblioth\u00e8ques d\u00e9crites pr\u00e9c\u00e9demment ainsi que des projets . Fichiers Audio Biblioth\u00e8que audio Fichiers FatFs FatFs Projet SD + Audio + FreeRTOS Projet vierge Enregistreur vocal Projet d'Informatique Industrielle","title":"Fichiers"},{"location":"files/#fichiers-stm32f746g-discovery","text":"Vous retrouverez ici les .h et .c n\u00e9cessaires au bon fonctionnement des biblioth\u00e8ques d\u00e9crites pr\u00e9c\u00e9demment ainsi que des projets .","title":"Fichiers STM32F746G-Discovery"},{"location":"files/#fichiers-audio","text":"Biblioth\u00e8que audio","title":"Fichiers Audio"},{"location":"files/#fichiers-fatfs","text":"FatFs","title":"Fichiers FatFs"},{"location":"files/#projet-sd-audio-freertos","text":"Projet vierge","title":"Projet SD + Audio + FreeRTOS"},{"location":"files/#enregistreur-vocal","text":"Projet d'Informatique Industrielle","title":"Enregistreur vocal"},{"location":"sd/","text":"Carte SD Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation de la carte SD ainsi que son utilisation. La communication avec la carte SD se fera \u00e0 l'aide de l'interface SDMMC ainsi que le DMA. Documentation SDMMC L'interface SDMMC permet la communication avec des MultiMediaCards (MMC), Secure Digital (SD) memory cards et autres p\u00e9riph\u00e9riques SD (Avec une fr\u00e9quence d'horloge allant jusqu'\u00e0 50 Mhz). L'interface SDMMC permet de g\u00e9rer des bus de donn\u00e9es de 1-bit, 4-bits et 8-bits. Parmi 3 interfaces possibles (SPI, SDIO,SDMMC) pour communiquer avec la carte SD l'interface SDMMC est la plus rapide, flexible mais plus complexe et poss\u00e9dant plus d'E/S. Diagramme SDMMC Lien pr\u00e9sentation SDMMC Lien doc SDMMC FatFs FAT, acronyme de file allocation table est un syst\u00e8me de fichiers (Organisation des fichiers au sein d'un volume logique) devenu un standard de l'industrie. Il est simple et robuste et tout \u00e0 fait adapt\u00e9 \u00e0 l'utilisation pour une carte SD pour de l'embarqu\u00e9. Lien doc FatFs Ajout la biblioth\u00e8que SD Vid\u00e9o de cr\u00e9ation d'un nouveau projet pour l'utilisation de la carte SD On se rend sur l'interface de configuration graphique de STM32CubeMX, puis on active le p\u00e9riph\u00e9rique SDMMC1 dans Connectivity. On ajoute la communication par DMA en gardant les param\u00e8tres par d\u00e9faut. Pour enfin ajouter le module FatFs en activant le template DMA. Enfin, on n'oubliera pas de changer la configuration du connecteur dans Project Manager. Attention particuli\u00e8re \u00e0 l'utilisation de la SDRAM en parall\u00e8le. V\u00e9rifier bien que les m\u00e9moires utilis\u00e9es de s'entrem\u00ealent pas auquel cas prenez garde \u00e0 la corruption de la carte ! Fonctions principales","title":"Carte SD"},{"location":"sd/#carte-sd","text":"Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation de la carte SD ainsi que son utilisation. La communication avec la carte SD se fera \u00e0 l'aide de l'interface SDMMC ainsi que le DMA.","title":"Carte SD"},{"location":"sd/#documentation","text":"","title":"Documentation"},{"location":"sd/#sdmmc","text":"L'interface SDMMC permet la communication avec des MultiMediaCards (MMC), Secure Digital (SD) memory cards et autres p\u00e9riph\u00e9riques SD (Avec une fr\u00e9quence d'horloge allant jusqu'\u00e0 50 Mhz). L'interface SDMMC permet de g\u00e9rer des bus de donn\u00e9es de 1-bit, 4-bits et 8-bits. Parmi 3 interfaces possibles (SPI, SDIO,SDMMC) pour communiquer avec la carte SD l'interface SDMMC est la plus rapide, flexible mais plus complexe et poss\u00e9dant plus d'E/S. Diagramme SDMMC Lien pr\u00e9sentation SDMMC Lien doc SDMMC","title":"SDMMC"},{"location":"sd/#fatfs","text":"FAT, acronyme de file allocation table est un syst\u00e8me de fichiers (Organisation des fichiers au sein d'un volume logique) devenu un standard de l'industrie. Il est simple et robuste et tout \u00e0 fait adapt\u00e9 \u00e0 l'utilisation pour une carte SD pour de l'embarqu\u00e9. Lien doc FatFs","title":"FatFs"},{"location":"sd/#ajout-la-bibliotheque-sd","text":"Vid\u00e9o de cr\u00e9ation d'un nouveau projet pour l'utilisation de la carte SD On se rend sur l'interface de configuration graphique de STM32CubeMX, puis on active le p\u00e9riph\u00e9rique SDMMC1 dans Connectivity. On ajoute la communication par DMA en gardant les param\u00e8tres par d\u00e9faut. Pour enfin ajouter le module FatFs en activant le template DMA. Enfin, on n'oubliera pas de changer la configuration du connecteur dans Project Manager. Attention particuli\u00e8re \u00e0 l'utilisation de la SDRAM en parall\u00e8le. V\u00e9rifier bien que les m\u00e9moires utilis\u00e9es de s'entrem\u00ealent pas auquel cas prenez garde \u00e0 la corruption de la carte !","title":"Ajout la biblioth\u00e8que SD"},{"location":"sd/#fonctions-principales","text":"","title":"Fonctions principales"}]}