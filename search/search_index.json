{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur le projet d'enregistreur vocal ! Introduction Paricipant \u00e0 un TER sur de la reconnaissance vocale, la g\u00e9n\u00e9ration d'un mod\u00e8le de reconnaissance vocale n\u00e9cessite d'avoir un dictionnaire de mot et des enregistrements audio associ\u00e9s. Ce dictionnaire contient nottament des nom de cellules qui ne se trouvent pas dans les bases de donn\u00e9es open-source. Ainsi, nous avons cr\u00e9\u00e9 un script Matlab permettant d'enregistrer la voix de volontaires. Afin de permettre d'enregistrer un plus grand nombre de donn\u00e9es, j'ai d\u00e9cid\u00e9 de porter ce script sous forme d'application sur la carte STM32F746G. Voici donc la nouvelle carte. Carte STM32F746G-Discovery et son extension Ainsi que le sch\u00e9ma synoptique expliquant le fonctionnement du projet. Sch\u00e9ma synoptique Besoins du projet Nous avons besoin de receuillir des fichiers audio pour une liste de mot appel\u00e9e dictionnaire. Pour ce faire, la carte dispose d'un Codec audio permettant de faire l'acquisition de la voix par l'interface de deux microphones sur la carte. Le but \u00e9tant de pouvoir r\u00e9cup\u00e9rer ces acquisitions pour les donner \u00e0 un r\u00e9seau de neuronnes con\u00e7u pour g\u00e9n\u00e9rer un mod\u00e8le de reconnaissance vocale, il faut les enregistrer sur un espace de stockage amovible. Bingo ! il y a un slot pour carte micro-SD. Probl\u00e9matiques Fichier .wav Afin d'enregistrer des fichiers audio, il faut pouvoir les stocker sous format .wav sur la carte. Il faut pour cela, \u00e9crire une ent\u00eate dans les fichiers permettant de reconna\u00eetre le type : [Bloc de d\u00e9claration d'un fichier au format WAVE] FileTypeBlocID (4 octets) : Constante \u00ab RIFF \u00bb (0x52,0x49,0x46,0x46) FileSize (4 octets) : Taille du fichier moins 8 octets FileFormatID (4 octets) : Format = \u00ab WAVE \u00bb (0x57,0x41,0x56,0x45) [Bloc d\u00e9crivant le format audio] FormatBlocID (4 octets) : Identifiant \u00ab fmt\u2423 \u00bb (0x66,0x6D, 0x74,0x20) BlocSize (4 octets) : Nombre d'octets du bloc - 16 (0x10) AudioFormat (2 octets) : Format du stockage dans le fichier (1: PCM entier, 3: PCM flottant, 65534: WAVE_FORMAT_EXTENSIBLE) NbrCanaux (2 octets) : Nombre de canaux (de 1 \u00e0 6, cf. ci-dessous) Frequence (4 octets) : Fr\u00e9quence d'\u00e9chantillonnage (en hertz) [Valeurs standardis\u00e9es : 11 025, 22 050, 44 100 et \u00e9ventuellement 48 000 et 96 000] BytePerSec (4 octets) : Nombre d'octets \u00e0 lire par seconde (c.-\u00e0-d., Frequence * BytePerBloc). BytePerBloc (2 octets) : Nombre d'octets par bloc d'\u00e9chantillonnage (c.-\u00e0-d., tous canaux confondus : NbrCanaux * BitsPerSample/8). BitsPerSample (2 octets) : Nombre de bits utilis\u00e9s pour le codage de chaque \u00e9chantillon (8, 16, 24) [Bloc des donn\u00e9es] DataBlocID (4 octets) : Constante \u00ab data \u00bb (0x64,0x61,0x74,0x61) DataSize (4 octets) : Nombre d'octets des donn\u00e9es (c.-\u00e0-d. \"Data[]\", c.-\u00e0-d. taille_du_fichier - taille_de_l'ent\u00eate (qui fait 44 octets normalement). DATAS[] : [Octets du Sample 1 du Canal 1] [Octets du Sample 1 du Canal 2] [Octets du Sample 2 du Canal 1] [Octets du Sample 2 du Canal 2] * Les Canaux : 1 pour mono, 2 pour st\u00e9r\u00e9o NOTES IMPORTANTES : Les octets des mots sont stock\u00e9s sous la forme Petit-boutiste (c.-\u00e0-d., en \"little endian\") [87654321][16..9][24..17] [8..1][16..9][24..17] [... On remarque la n\u00e9cessit\u00e9 de conna\u00eetre la taille de l'\u00e9chantillon \u00e0 sauvegarder. La dur\u00e9e d'enregistrement de chaque mots n'exc\u00e9dent pas 4 secondes, soit pour une fr\u00e9quence d'\u00e9chantillonnage de 16 kHz, une taille de 64 Ko en mono. La taille de la RAM dont dispose la carte STM32 est de 340 Ko, il n'y aura a priori pas de probl\u00e8me majeur pour stocker chaque \u00e9chantillon sur la carte entre deux \u00e9critures sur la carte SD. Pour des enregistrements plus cons\u00e9quents, on pourra toujours utiliser la SDRAM pouvant stocker jusqu'\u00e0 64 Mo. Probl\u00e8mes rencontr\u00e9s La partie posant le plus de soucis est la carteSD ainsi que la m\u00e9moire allou\u00e9e \u00e0 FreeRTOS et aux t\u00e2ches. Le premier soucis appara\u00eet \u00e0 une allocation sup\u00e9rieure \u00e0 60000 octets \u00e0 freeRTOS o\u00f9 le formatage se passe correctement mais l'\u00e9criture d'un fichier indique un mauvais formatage. Le second appara\u00eet \u00e0 l'allocation de la m\u00e9moire aux t\u00e2ches, une allocation trop importante (>4096) peut entra\u00eener un disfonctionnement. De plus, la biblioth\u00e8que de fonctionnement de la carte SD n'est pas enti\u00e8rement FreeRTOS proof. En effet, certaine fonctionnalit\u00e9s sont bloqu\u00e9es lors de la configuration du .ioc (elles ne sont pas forc\u00e9ment bloqu\u00e9es \u00e0 la s\u00e9lection, cependant le programme ne fonctionne plus une fois compil\u00e9).","title":"Projet"},{"location":"#bienvenue-sur-le-projet-denregistreur-vocal","text":"","title":"Bienvenue sur le projet d'enregistreur vocal !"},{"location":"#introduction","text":"Paricipant \u00e0 un TER sur de la reconnaissance vocale, la g\u00e9n\u00e9ration d'un mod\u00e8le de reconnaissance vocale n\u00e9cessite d'avoir un dictionnaire de mot et des enregistrements audio associ\u00e9s. Ce dictionnaire contient nottament des nom de cellules qui ne se trouvent pas dans les bases de donn\u00e9es open-source. Ainsi, nous avons cr\u00e9\u00e9 un script Matlab permettant d'enregistrer la voix de volontaires. Afin de permettre d'enregistrer un plus grand nombre de donn\u00e9es, j'ai d\u00e9cid\u00e9 de porter ce script sous forme d'application sur la carte STM32F746G. Voici donc la nouvelle carte. Carte STM32F746G-Discovery et son extension Ainsi que le sch\u00e9ma synoptique expliquant le fonctionnement du projet. Sch\u00e9ma synoptique","title":"Introduction"},{"location":"#besoins-du-projet","text":"Nous avons besoin de receuillir des fichiers audio pour une liste de mot appel\u00e9e dictionnaire. Pour ce faire, la carte dispose d'un Codec audio permettant de faire l'acquisition de la voix par l'interface de deux microphones sur la carte. Le but \u00e9tant de pouvoir r\u00e9cup\u00e9rer ces acquisitions pour les donner \u00e0 un r\u00e9seau de neuronnes con\u00e7u pour g\u00e9n\u00e9rer un mod\u00e8le de reconnaissance vocale, il faut les enregistrer sur un espace de stockage amovible. Bingo ! il y a un slot pour carte micro-SD.","title":"Besoins du projet"},{"location":"#problematiques","text":"","title":"Probl\u00e9matiques"},{"location":"#fichier-wav","text":"Afin d'enregistrer des fichiers audio, il faut pouvoir les stocker sous format .wav sur la carte. Il faut pour cela, \u00e9crire une ent\u00eate dans les fichiers permettant de reconna\u00eetre le type : [Bloc de d\u00e9claration d'un fichier au format WAVE] FileTypeBlocID (4 octets) : Constante \u00ab RIFF \u00bb (0x52,0x49,0x46,0x46) FileSize (4 octets) : Taille du fichier moins 8 octets FileFormatID (4 octets) : Format = \u00ab WAVE \u00bb (0x57,0x41,0x56,0x45) [Bloc d\u00e9crivant le format audio] FormatBlocID (4 octets) : Identifiant \u00ab fmt\u2423 \u00bb (0x66,0x6D, 0x74,0x20) BlocSize (4 octets) : Nombre d'octets du bloc - 16 (0x10) AudioFormat (2 octets) : Format du stockage dans le fichier (1: PCM entier, 3: PCM flottant, 65534: WAVE_FORMAT_EXTENSIBLE) NbrCanaux (2 octets) : Nombre de canaux (de 1 \u00e0 6, cf. ci-dessous) Frequence (4 octets) : Fr\u00e9quence d'\u00e9chantillonnage (en hertz) [Valeurs standardis\u00e9es : 11 025, 22 050, 44 100 et \u00e9ventuellement 48 000 et 96 000] BytePerSec (4 octets) : Nombre d'octets \u00e0 lire par seconde (c.-\u00e0-d., Frequence * BytePerBloc). BytePerBloc (2 octets) : Nombre d'octets par bloc d'\u00e9chantillonnage (c.-\u00e0-d., tous canaux confondus : NbrCanaux * BitsPerSample/8). BitsPerSample (2 octets) : Nombre de bits utilis\u00e9s pour le codage de chaque \u00e9chantillon (8, 16, 24) [Bloc des donn\u00e9es] DataBlocID (4 octets) : Constante \u00ab data \u00bb (0x64,0x61,0x74,0x61) DataSize (4 octets) : Nombre d'octets des donn\u00e9es (c.-\u00e0-d. \"Data[]\", c.-\u00e0-d. taille_du_fichier - taille_de_l'ent\u00eate (qui fait 44 octets normalement). DATAS[] : [Octets du Sample 1 du Canal 1] [Octets du Sample 1 du Canal 2] [Octets du Sample 2 du Canal 1] [Octets du Sample 2 du Canal 2] * Les Canaux : 1 pour mono, 2 pour st\u00e9r\u00e9o NOTES IMPORTANTES : Les octets des mots sont stock\u00e9s sous la forme Petit-boutiste (c.-\u00e0-d., en \"little endian\") [87654321][16..9][24..17] [8..1][16..9][24..17] [... On remarque la n\u00e9cessit\u00e9 de conna\u00eetre la taille de l'\u00e9chantillon \u00e0 sauvegarder. La dur\u00e9e d'enregistrement de chaque mots n'exc\u00e9dent pas 4 secondes, soit pour une fr\u00e9quence d'\u00e9chantillonnage de 16 kHz, une taille de 64 Ko en mono. La taille de la RAM dont dispose la carte STM32 est de 340 Ko, il n'y aura a priori pas de probl\u00e8me majeur pour stocker chaque \u00e9chantillon sur la carte entre deux \u00e9critures sur la carte SD. Pour des enregistrements plus cons\u00e9quents, on pourra toujours utiliser la SDRAM pouvant stocker jusqu'\u00e0 64 Mo.","title":"Fichier .wav"},{"location":"#problemes-rencontres","text":"La partie posant le plus de soucis est la carteSD ainsi que la m\u00e9moire allou\u00e9e \u00e0 FreeRTOS et aux t\u00e2ches. Le premier soucis appara\u00eet \u00e0 une allocation sup\u00e9rieure \u00e0 60000 octets \u00e0 freeRTOS o\u00f9 le formatage se passe correctement mais l'\u00e9criture d'un fichier indique un mauvais formatage. Le second appara\u00eet \u00e0 l'allocation de la m\u00e9moire aux t\u00e2ches, une allocation trop importante (>4096) peut entra\u00eener un disfonctionnement. De plus, la biblioth\u00e8que de fonctionnement de la carte SD n'est pas enti\u00e8rement FreeRTOS proof. En effet, certaine fonctionnalit\u00e9s sont bloqu\u00e9es lors de la configuration du .ioc (elles ne sont pas forc\u00e9ment bloqu\u00e9es \u00e0 la s\u00e9lection, cependant le programme ne fonctionne plus une fois compil\u00e9).","title":"Probl\u00e8mes rencontr\u00e9s"},{"location":"app/","text":"Cr\u00e9ation de l'application Il a fallu cr\u00e9er un environnement adapt\u00e9 \u00e0 l'utilisateur, c'est-\u00e0-dire une interface graphique permettant d'utiliser l'application facilement. On retrouve alors l'interface suivante, Carte STM32F746G-Discovery et son extension O\u00f9 plusieurs boutons sont disponibles, ils permettent le changement de mot \u00e0 enregistrer, l'enregistrement et l'\u00e9coute a-posteriori pour confirmer la prise de son et enfin des boutons de gestion de la carte SD \u00e0 droite, dont seul le formatage fonctionne. La zone de saisie de texte fait appara\u00eetre un clavier tactile permettant d'identifier l'utilisateur et ainsi de cr\u00e9er un r\u00e9pertoire \u00e0 son nom. Ceci facilitera le traitement des donn\u00e9es par la suite. Carte STM32F746G-Discovery et son extension","title":"Application"},{"location":"app/#creation-de-lapplication","text":"Il a fallu cr\u00e9er un environnement adapt\u00e9 \u00e0 l'utilisateur, c'est-\u00e0-dire une interface graphique permettant d'utiliser l'application facilement. On retrouve alors l'interface suivante, Carte STM32F746G-Discovery et son extension O\u00f9 plusieurs boutons sont disponibles, ils permettent le changement de mot \u00e0 enregistrer, l'enregistrement et l'\u00e9coute a-posteriori pour confirmer la prise de son et enfin des boutons de gestion de la carte SD \u00e0 droite, dont seul le formatage fonctionne. La zone de saisie de texte fait appara\u00eetre un clavier tactile permettant d'identifier l'utilisateur et ainsi de cr\u00e9er un r\u00e9pertoire \u00e0 son nom. Ceci facilitera le traitement des donn\u00e9es par la suite. Carte STM32F746G-Discovery et son extension","title":"Cr\u00e9ation de l'application"},{"location":"audio/","text":"Audio Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation du codec audio WM8994 ainsi que son utilisation. La communication avec le codec se fera \u00e0 l'aide de l'interface SAI. Documentation Codec WM8994 Un Codec est un dispositif mat\u00e9riel permettant de mettre en oeuvre l'encode ou le d\u00e9codage d'un flux de donn\u00e9es num\u00e9rique, en vue d'une transmission ou d'un stockage. I/O Codec WM8994 Celui-ci pr\u00e9sente Lien doc WM8994 SAI Diagramme SAI Lien doc SAI DMA Lien doc DMA Ajout de la biblioth\u00e8que On active l'interface SAI dans Multimedia avec une liaison Maitre et une laison Esclave synchrone. Les requ\u00eates se font alors avec le DMA avec la configuration suivante Une fois tout ceci fait, on peut rajouter les headers et fichiers sources dans notre projet. Fonctions principales Initialisations Initialiser l'enregistrement uint8_t BSP_AUDIO_IN_InitEx ( uint16_t InputDevice /* INPUT_DEVICE_DIGITAL_MICROPHONE_2 or INPUT_DEVICE_INPUT_LINE_1 */ uint32_t AudioFreq, /* Audio frequency to be configured for the SAI peripheral */ uint32_t BitRes, /* Audio frequency to be configured */ uint32_t ChnlNbr /* Channel number */ ) Initialiser le p\u00e9riph\u00e9rique de sortie uint8_t BSP_AUDIO_OUT_Init ( uint16_t OutputDevice, /* OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE, or OUTPUT_DEVICE_BOTH */ uint8_t Volume, /* Initial volume level (from 0 (Mute) to 100 (Max)) */ uint32_t AudioFreq /* Audio frequency used to play the audio stream */ ) Gestion du stream audio Jouer un stream audio depuis un buffer de donn\u00e9es uint8_t BSP_AUDIO_OUT_Play ( uint16_t *pBuffer, /* Pointer to the buffer */ uint32_t Size) /* Number of audio data in BYTES unit */ *** Dans la m\u00e9moire, les octets sont altern\u00e9s entre canal gauche puis canal droit Pause uint8_t BSP_AUDIO_OUT_Pause(void) Resume uint8_t BSP_AUDIO_OUT_Resume(void) Arr\u00eat uint8_t BSP_AUDIO_OUT_Stop( uint32_t Option /* - CODEC_PDWN_SW: for software power off (by writing registers). Then no need to reconfigure the Codec after power on. - CODEC_PDWN_HW: completely shut down the codec (physically). Then need to reconfigure the Codec after power on. */ ) R\u00e9gler le volume de sortie uint8_t BSP_AUDIO_OUT_SetVolume( uint8_t Volume /* Volume level to be set in percentage from 0% to 100% (0 for Mute and 100 for Max volume level) */ ) Callbacks de transfert SAI void HAL_SAI_TxCpltCallback( SAI_HandleTypeDef *hsai /* SAI handle */ ) void HAL_SAI_TxHalfCpltCallback( SAI_HandleTypeDef *hsai /* SAI handle */ ) Callbacks d'enregistrement void BSP_AUDIO_IN_HalfTransfer_CallBack(void) void BSP_AUDIO_IN_TransferComplete_CallBack(void) Code erreur AUDIO_OK ((uint8_t)0) AUDIO_ERROR ((uint8_t)1) AUDIO_TIMEOUT ((uint8_t)2)","title":"Audio"},{"location":"audio/#audio","text":"Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation du codec audio WM8994 ainsi que son utilisation. La communication avec le codec se fera \u00e0 l'aide de l'interface SAI.","title":"Audio"},{"location":"audio/#documentation","text":"","title":"Documentation"},{"location":"audio/#codec-wm8994","text":"Un Codec est un dispositif mat\u00e9riel permettant de mettre en oeuvre l'encode ou le d\u00e9codage d'un flux de donn\u00e9es num\u00e9rique, en vue d'une transmission ou d'un stockage. I/O Codec WM8994 Celui-ci pr\u00e9sente Lien doc WM8994","title":"Codec WM8994"},{"location":"audio/#sai","text":"Diagramme SAI Lien doc SAI","title":"SAI"},{"location":"audio/#dma","text":"Lien doc DMA","title":"DMA"},{"location":"audio/#ajout-de-la-bibliotheque","text":"On active l'interface SAI dans Multimedia avec une liaison Maitre et une laison Esclave synchrone. Les requ\u00eates se font alors avec le DMA avec la configuration suivante Une fois tout ceci fait, on peut rajouter les headers et fichiers sources dans notre projet.","title":"Ajout de la biblioth\u00e8que"},{"location":"audio/#fonctions-principales","text":"","title":"Fonctions principales"},{"location":"audio/#initialisations","text":"","title":"Initialisations"},{"location":"audio/#initialiser-lenregistrement","text":"uint8_t BSP_AUDIO_IN_InitEx ( uint16_t InputDevice /* INPUT_DEVICE_DIGITAL_MICROPHONE_2 or INPUT_DEVICE_INPUT_LINE_1 */ uint32_t AudioFreq, /* Audio frequency to be configured for the SAI peripheral */ uint32_t BitRes, /* Audio frequency to be configured */ uint32_t ChnlNbr /* Channel number */ )","title":"Initialiser l'enregistrement"},{"location":"audio/#initialiser-le-peripherique-de-sortie","text":"uint8_t BSP_AUDIO_OUT_Init ( uint16_t OutputDevice, /* OUTPUT_DEVICE_SPEAKER, OUTPUT_DEVICE_HEADPHONE, or OUTPUT_DEVICE_BOTH */ uint8_t Volume, /* Initial volume level (from 0 (Mute) to 100 (Max)) */ uint32_t AudioFreq /* Audio frequency used to play the audio stream */ )","title":"Initialiser le p\u00e9riph\u00e9rique de sortie"},{"location":"audio/#gestion-du-stream-audio","text":"","title":"Gestion du stream audio"},{"location":"audio/#jouer-un-stream-audio-depuis-un-buffer-de-donnees","text":"uint8_t BSP_AUDIO_OUT_Play ( uint16_t *pBuffer, /* Pointer to the buffer */ uint32_t Size) /* Number of audio data in BYTES unit */ *** Dans la m\u00e9moire, les octets sont altern\u00e9s entre canal gauche puis canal droit","title":"Jouer un stream audio depuis un buffer de donn\u00e9es"},{"location":"audio/#pause","text":"uint8_t BSP_AUDIO_OUT_Pause(void)","title":"Pause"},{"location":"audio/#resume","text":"uint8_t BSP_AUDIO_OUT_Resume(void)","title":"Resume"},{"location":"audio/#arret","text":"uint8_t BSP_AUDIO_OUT_Stop( uint32_t Option /* - CODEC_PDWN_SW: for software power off (by writing registers). Then no need to reconfigure the Codec after power on. - CODEC_PDWN_HW: completely shut down the codec (physically). Then need to reconfigure the Codec after power on. */ )","title":"Arr\u00eat"},{"location":"audio/#regler-le-volume-de-sortie","text":"uint8_t BSP_AUDIO_OUT_SetVolume( uint8_t Volume /* Volume level to be set in percentage from 0% to 100% (0 for Mute and 100 for Max volume level) */ )","title":"R\u00e9gler le volume de sortie"},{"location":"audio/#callbacks-de-transfert-sai","text":"void HAL_SAI_TxCpltCallback( SAI_HandleTypeDef *hsai /* SAI handle */ ) void HAL_SAI_TxHalfCpltCallback( SAI_HandleTypeDef *hsai /* SAI handle */ )","title":"Callbacks de transfert SAI"},{"location":"audio/#callbacks-denregistrement","text":"void BSP_AUDIO_IN_HalfTransfer_CallBack(void) void BSP_AUDIO_IN_TransferComplete_CallBack(void)","title":"Callbacks d'enregistrement"},{"location":"audio/#code-erreur","text":"AUDIO_OK ((uint8_t)0) AUDIO_ERROR ((uint8_t)1) AUDIO_TIMEOUT ((uint8_t)2)","title":"Code erreur"},{"location":"files/","text":"Fichiers STM32F746G-Discovery Vous retrouverez ici les .h et .c n\u00e9cessaires au bon fonctionnement des biblioth\u00e8ques d\u00e9crites pr\u00e9c\u00e9demment ainsi que des projets . Fiche de cours RTOS RTOS Fichiers Audio Biblioth\u00e8que audio Fichiers FatFs FatFs Projet SD + Audio + FreeRTOS Projet vierge Enregistreur vocal Projet d'Informatique Industrielle","title":"Fichiers"},{"location":"files/#fichiers-stm32f746g-discovery","text":"Vous retrouverez ici les .h et .c n\u00e9cessaires au bon fonctionnement des biblioth\u00e8ques d\u00e9crites pr\u00e9c\u00e9demment ainsi que des projets .","title":"Fichiers STM32F746G-Discovery"},{"location":"files/#fiche-de-cours-rtos","text":"RTOS","title":"Fiche de cours RTOS"},{"location":"files/#fichiers-audio","text":"Biblioth\u00e8que audio","title":"Fichiers Audio"},{"location":"files/#fichiers-fatfs","text":"FatFs","title":"Fichiers FatFs"},{"location":"files/#projet-sd-audio-freertos","text":"Projet vierge","title":"Projet SD + Audio + FreeRTOS"},{"location":"files/#enregistreur-vocal","text":"Projet d'Informatique Industrielle","title":"Enregistreur vocal"},{"location":"sd/","text":"Carte SD Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation de la carte SD ainsi que son utilisation. La communication avec la carte SD se fera \u00e0 l'aide de l'interface SDMMC ainsi que le DMA. Documentation SDMMC L'interface SDMMC permet la communication avec des MultiMediaCards (MMC), Secure Digital (SD) memory cards et autres p\u00e9riph\u00e9riques SD (Avec une fr\u00e9quence d'horloge allant jusqu'\u00e0 50 Mhz). L'interface SDMMC permet de g\u00e9rer des bus de donn\u00e9es de 1-bit, 4-bits et 8-bits. Parmi 3 interfaces possibles (SPI, SDIO,SDMMC) pour communiquer avec la carte SD l'interface SDMMC est la plus rapide, flexible mais plus complexe et poss\u00e9dant plus d'E/S. Diagramme SDMMC Lien pr\u00e9sentation SDMMC Lien doc SDMMC FatFs FAT, acronyme de file allocation table est un syst\u00e8me de fichiers (Organisation des fichiers au sein d'un volume logique) devenu un standard de l'industrie. Il est simple et robuste et tout \u00e0 fait adapt\u00e9 \u00e0 l'utilisation pour une carte SD pour de l'embarqu\u00e9. Lien doc FatFs Ajout la biblioth\u00e8que SD Vid\u00e9o de cr\u00e9ation d'un nouveau projet pour l'utilisation de la carte SD On se rend sur l'interface de configuration graphique de STM32CubeMX, puis on active le p\u00e9riph\u00e9rique SDMMC1 dans Connectivity. On ajoute la communication par DMA en gardant les param\u00e8tres par d\u00e9faut. Pour enfin ajouter le module FatFs en activant le template DMA. Enfin, on n'oubliera pas de changer la configuration du connecteur dans Project Manager. Attention particuli\u00e8re \u00e0 l'utilisation de la carteSD avec FreeRTOS, il se peut qu'il y ai certaines collisions dans la m\u00e9moire ! Il ne faut pas d\u00e9passer 60000 octets dans l'allocation \u00e0 FreeRTOS. Il ne faut pas non plus d\u00e9passer les 4096 octets par t\u00e2che au quel cas m\u00eame probl\u00e8me. Les noms des fichiers sont limit\u00e9s \u00e0 10 caract\u00e8res, faites donc bien attention ! (L'erreur sera report\u00e9e avec le code erreur 6) Fonctions principales Gestion de la carte SD Monter/d\u00e9monter la carte SD FRESULT f_mount ( FATFS* fs, /* Pointer to the file system object (NULL:unmount)*/ const TCHAR* path, /* Logical drive number to be mounted/unmounted */ BYTE opt /* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */ ) Cr\u00e9er un volume FRESULT f_mkfs ( const TCHAR* path, /* Logical drive number */ BYTE opt, /* Format option */ DWORD au, /* Size of allocation unit (cluster) [byte] */ void* work, /* Pointer to working buffer */ UINT len /* Size of working buffer */ ) Gestion des donn\u00e9es Ouvrir ou cr\u00e9er un fichier RESULT f_open ( FIL* fp, /* Pointer to the blank file object */ const TCHAR* path, /* Pointer to the file name */ BYTE mode /* Access mode and file open mode flags */ ) Lire dans un fichier FRESULT f_read ( FIL* fp, /* Pointer to the file object */ void* buff, /* Pointer to data buffer */ UINT btr, /* Number of bytes to read */ UINT* br /* Pointer to number of bytes read */ ) Ecrire dans un fichier FRESULT f_write ( FIL* fp, /* Pointer to the file object */ const void* buff, /* Pointer to the data to be written */ UINT btw, /* Number of bytes to write */ UINT* bw /* Pointer to number of bytes written */ ) Ouvrir un r\u00e9pertoire FRESULT f_opendir ( DIR* dp, /* Pointer to directory object to create */ const TCHAR* path /* Pointer to the directory path */ ) Fermer un r\u00e9pertoire FRESULT f_closedir ( DIR *dp /* Pointer to the directory object to be closed */ ) Cr\u00e9er un r\u00e9pertoire FRESULT f_mkdir ( const TCHAR* path /* Pointer to the directory path */ ) Changer de r\u00e9pertoire FRESULT f_chdir ( const TCHAR* path /* Pointer to the directory path */ ) Codes erreur FR_OK = 0, /* (0) Succeeded */ FR_DISK_ERR, /* (1) A hard error occurred in the low level disk I/O layer */ FR_INT_ERR, /* (2) Assertion failed */ FR_NOT_READY, /* (3) The physical drive cannot work */ FR_NO_FILE, /* (4) Could not find the file */ FR_NO_PATH, /* (5) Could not find the path */ FR_INVALID_NAME, /* (6) The path name format is invalid */ FR_DENIED, /* (7) Access denied due to prohibited access or directory full */ FR_EXIST, /* (8) Access denied due to prohibited access */ FR_INVALID_OBJECT, /* (9) The file/directory object is invalid */ FR_WRITE_PROTECTED, /* (10) The physical drive is write protected */ FR_INVALID_DRIVE, /* (11) The logical drive number is invalid */ FR_NOT_ENABLED, /* (12) The volume has no work area */ FR_NO_FILESYSTEM, /* (13) There is no valid FAT volume */ FR_MKFS_ABORTED, /* (14) The f_mkfs() aborted due to any problem */ FR_TIMEOUT, /* (15) Could not get a grant to access the volume within defined period */ FR_LOCKED, /* (16) The operation is rejected according to the file sharing policy */ FR_NOT_ENOUGH_CORE, /* (17) LFN working buffer could not be allocated */ FR_TOO_MANY_OPEN_FILES, /* (18) Number of open files > _FS_LOCK */ FR_INVALID_PARAMETER /* (19) Given parameter is invalid */","title":"Carte SD"},{"location":"sd/#carte-sd","text":"Dans cette partie, nous verrons l'ajout de la biblioth\u00e8que pour l'utilisation de la carte SD ainsi que son utilisation. La communication avec la carte SD se fera \u00e0 l'aide de l'interface SDMMC ainsi que le DMA.","title":"Carte SD"},{"location":"sd/#documentation","text":"","title":"Documentation"},{"location":"sd/#sdmmc","text":"L'interface SDMMC permet la communication avec des MultiMediaCards (MMC), Secure Digital (SD) memory cards et autres p\u00e9riph\u00e9riques SD (Avec une fr\u00e9quence d'horloge allant jusqu'\u00e0 50 Mhz). L'interface SDMMC permet de g\u00e9rer des bus de donn\u00e9es de 1-bit, 4-bits et 8-bits. Parmi 3 interfaces possibles (SPI, SDIO,SDMMC) pour communiquer avec la carte SD l'interface SDMMC est la plus rapide, flexible mais plus complexe et poss\u00e9dant plus d'E/S. Diagramme SDMMC Lien pr\u00e9sentation SDMMC Lien doc SDMMC","title":"SDMMC"},{"location":"sd/#fatfs","text":"FAT, acronyme de file allocation table est un syst\u00e8me de fichiers (Organisation des fichiers au sein d'un volume logique) devenu un standard de l'industrie. Il est simple et robuste et tout \u00e0 fait adapt\u00e9 \u00e0 l'utilisation pour une carte SD pour de l'embarqu\u00e9. Lien doc FatFs","title":"FatFs"},{"location":"sd/#ajout-la-bibliotheque-sd","text":"Vid\u00e9o de cr\u00e9ation d'un nouveau projet pour l'utilisation de la carte SD On se rend sur l'interface de configuration graphique de STM32CubeMX, puis on active le p\u00e9riph\u00e9rique SDMMC1 dans Connectivity. On ajoute la communication par DMA en gardant les param\u00e8tres par d\u00e9faut. Pour enfin ajouter le module FatFs en activant le template DMA. Enfin, on n'oubliera pas de changer la configuration du connecteur dans Project Manager. Attention particuli\u00e8re \u00e0 l'utilisation de la carteSD avec FreeRTOS, il se peut qu'il y ai certaines collisions dans la m\u00e9moire ! Il ne faut pas d\u00e9passer 60000 octets dans l'allocation \u00e0 FreeRTOS. Il ne faut pas non plus d\u00e9passer les 4096 octets par t\u00e2che au quel cas m\u00eame probl\u00e8me. Les noms des fichiers sont limit\u00e9s \u00e0 10 caract\u00e8res, faites donc bien attention ! (L'erreur sera report\u00e9e avec le code erreur 6)","title":"Ajout la biblioth\u00e8que SD"},{"location":"sd/#fonctions-principales","text":"","title":"Fonctions principales"},{"location":"sd/#gestion-de-la-carte-sd","text":"","title":"Gestion de la carte SD"},{"location":"sd/#monterdemonter-la-carte-sd","text":"FRESULT f_mount ( FATFS* fs, /* Pointer to the file system object (NULL:unmount)*/ const TCHAR* path, /* Logical drive number to be mounted/unmounted */ BYTE opt /* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */ )","title":"Monter/d\u00e9monter la carte SD"},{"location":"sd/#creer-un-volume","text":"FRESULT f_mkfs ( const TCHAR* path, /* Logical drive number */ BYTE opt, /* Format option */ DWORD au, /* Size of allocation unit (cluster) [byte] */ void* work, /* Pointer to working buffer */ UINT len /* Size of working buffer */ )","title":"Cr\u00e9er un volume"},{"location":"sd/#gestion-des-donnees","text":"","title":"Gestion des donn\u00e9es"},{"location":"sd/#ouvrir-ou-creer-un-fichier","text":"RESULT f_open ( FIL* fp, /* Pointer to the blank file object */ const TCHAR* path, /* Pointer to the file name */ BYTE mode /* Access mode and file open mode flags */ )","title":"Ouvrir ou cr\u00e9er un fichier"},{"location":"sd/#lire-dans-un-fichier","text":"FRESULT f_read ( FIL* fp, /* Pointer to the file object */ void* buff, /* Pointer to data buffer */ UINT btr, /* Number of bytes to read */ UINT* br /* Pointer to number of bytes read */ )","title":"Lire dans un fichier"},{"location":"sd/#ecrire-dans-un-fichier","text":"FRESULT f_write ( FIL* fp, /* Pointer to the file object */ const void* buff, /* Pointer to the data to be written */ UINT btw, /* Number of bytes to write */ UINT* bw /* Pointer to number of bytes written */ )","title":"Ecrire dans un fichier"},{"location":"sd/#ouvrir-un-repertoire","text":"FRESULT f_opendir ( DIR* dp, /* Pointer to directory object to create */ const TCHAR* path /* Pointer to the directory path */ )","title":"Ouvrir un r\u00e9pertoire"},{"location":"sd/#fermer-un-repertoire","text":"FRESULT f_closedir ( DIR *dp /* Pointer to the directory object to be closed */ )","title":"Fermer un r\u00e9pertoire"},{"location":"sd/#creer-un-repertoire","text":"FRESULT f_mkdir ( const TCHAR* path /* Pointer to the directory path */ )","title":"Cr\u00e9er un r\u00e9pertoire"},{"location":"sd/#changer-de-repertoire","text":"FRESULT f_chdir ( const TCHAR* path /* Pointer to the directory path */ )","title":"Changer de r\u00e9pertoire"},{"location":"sd/#codes-erreur","text":"FR_OK = 0, /* (0) Succeeded */ FR_DISK_ERR, /* (1) A hard error occurred in the low level disk I/O layer */ FR_INT_ERR, /* (2) Assertion failed */ FR_NOT_READY, /* (3) The physical drive cannot work */ FR_NO_FILE, /* (4) Could not find the file */ FR_NO_PATH, /* (5) Could not find the path */ FR_INVALID_NAME, /* (6) The path name format is invalid */ FR_DENIED, /* (7) Access denied due to prohibited access or directory full */ FR_EXIST, /* (8) Access denied due to prohibited access */ FR_INVALID_OBJECT, /* (9) The file/directory object is invalid */ FR_WRITE_PROTECTED, /* (10) The physical drive is write protected */ FR_INVALID_DRIVE, /* (11) The logical drive number is invalid */ FR_NOT_ENABLED, /* (12) The volume has no work area */ FR_NO_FILESYSTEM, /* (13) There is no valid FAT volume */ FR_MKFS_ABORTED, /* (14) The f_mkfs() aborted due to any problem */ FR_TIMEOUT, /* (15) Could not get a grant to access the volume within defined period */ FR_LOCKED, /* (16) The operation is rejected according to the file sharing policy */ FR_NOT_ENOUGH_CORE, /* (17) LFN working buffer could not be allocated */ FR_TOO_MANY_OPEN_FILES, /* (18) Number of open files > _FS_LOCK */ FR_INVALID_PARAMETER /* (19) Given parameter is invalid */","title":"Codes erreur"}]}